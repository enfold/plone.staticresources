{"version":3,"file":"chunks/2542.046ca9e3054971a06000.min.js","mappings":"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","sources":["webpack://plone.staticresources/../mockup/node_modules/@patternslib/patternslib/src/core/jquery-ext.js","webpack://plone.staticresources/../mockup/node_modules/@patternslib/patternslib/src/pat/ajax/ajax.js","webpack://plone.staticresources/../mockup/node_modules/@patternslib/patternslib/src/pat/inject/inject.js","webpack://plone.staticresources/../mockup/node_modules/@patternslib/patternslib/src/pat/markdown/markdown.js"],"sourcesContent":["/**\n * @license\n * Patterns @VERSION@ jquery-ext - various jQuery extensions\n *\n * Copyright 2011 Humberto Sermeño\n */\n\nimport $ from \"jquery\";\n\nvar methods = {\n    init: function (options) {\n        var settings = {\n            time: 3 /* time it will wait before moving to \"timeout\" after a move event */,\n            initialTime: 8 /* time it will wait before first adding the \"timeout\" class */,\n            exceptionAreas: [] /* IDs of elements that, if the mouse is over them, will reset the timer */,\n        };\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(\"timeout\");\n\n            if (!data) {\n                if (options) {\n                    $.extend(settings, options);\n                }\n                $this.data(\"timeout\", {\n                    lastEvent: new Date(),\n                    trueTime: settings.time,\n                    time: settings.initialTime,\n                    untouched: true,\n                    inExceptionArea: false,\n                });\n\n                $this.on(\"mouseover.timeout\", methods.mouseMoved);\n                $this.on(\"mouseenter.timeout\", methods.mouseMoved);\n\n                $(settings.exceptionAreas).each(function () {\n                    $this\n                        .find(this)\n                        .live(\n                            \"mouseover.timeout\",\n                            { parent: $this },\n                            methods.enteredException\n                        )\n                        .live(\n                            \"mouseleave.timeout\",\n                            { parent: $this },\n                            methods.leftException\n                        );\n                });\n\n                if (settings.initialTime > 0) $this.timeout(\"startTimer\");\n                else $this.addClass(\"timeout\");\n            }\n        });\n    },\n\n    enteredException: function (event) {\n        var data = event.data.parent.data(\"timeout\");\n        data.inExceptionArea = true;\n        event.data.parent.data(\"timeout\", data);\n        event.data.parent.trigger(\"mouseover\");\n    },\n\n    leftException: function (event) {\n        var data = event.data.parent.data(\"timeout\");\n        data.inExceptionArea = false;\n        event.data.parent.data(\"timeout\", data);\n    },\n\n    destroy: function () {\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(\"timeout\");\n\n            $(window).off(\".timeout\");\n            data.timeout.remove();\n            $this.removeData(\"timeout\");\n        });\n    },\n\n    mouseMoved: function () {\n        var $this = $(this),\n            data = $this.data(\"timeout\");\n\n        if ($this.hasClass(\"timeout\")) {\n            $this.removeClass(\"timeout\");\n            $this.timeout(\"startTimer\");\n        } else if (data.untouched) {\n            data.untouched = false;\n            data.time = data.trueTime;\n        }\n\n        data.lastEvent = new Date();\n        $this.data(\"timeout\", data);\n    },\n\n    startTimer: function () {\n        var $this = $(this),\n            data = $this.data(\"timeout\");\n        var fn = function () {\n            var data = $this.data(\"timeout\");\n            if (data && data.lastEvent) {\n                if (data.inExceptionArea) {\n                    setTimeout(fn, Math.floor(data.time * 1000));\n                } else {\n                    var now = new Date();\n                    var diff = Math.floor(data.time * 1000) - (now - data.lastEvent);\n                    if (diff > 0) {\n                        // the timeout has not ocurred, so set the timeout again\n                        setTimeout(fn, diff + 100);\n                    } else {\n                        // timeout ocurred, so set the class\n                        $this.addClass(\"timeout\");\n                    }\n                }\n            }\n        };\n\n        setTimeout(fn, Math.floor(data.time * 1000));\n    },\n};\n\n$.fn.timeout = function (method) {\n    if (methods[method]) {\n        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof method === \"object\" || !method) {\n        return methods.init.apply(this, arguments);\n    } else {\n        $.error(\"Method \" + method + \" does not exist on jQuery.timeout\");\n    }\n};\n\n// Custom jQuery selector to find elements with scrollbars\n$.extend($.expr[\":\"], {\n    scrollable: function (element) {\n        var vertically_scrollable, horizontally_scrollable;\n        if (\n            $(element).css(\"overflow\") === \"scroll\" ||\n            $(element).css(\"overflowX\") === \"scroll\" ||\n            $(element).css(\"overflowY\") === \"scroll\"\n        )\n            return true;\n\n        vertically_scrollable =\n            element.clientHeight < element.scrollHeight &&\n            ($.inArray($(element).css(\"overflowY\"), [\"scroll\", \"auto\"]) !== -1 ||\n                $.inArray($(element).css(\"overflow\"), [\"scroll\", \"auto\"]) !== -1);\n\n        if (vertically_scrollable) return true;\n\n        horizontally_scrollable =\n            element.clientWidth < element.scrollWidth &&\n            ($.inArray($(element).css(\"overflowX\"), [\"scroll\", \"auto\"]) !== -1 ||\n                $.inArray($(element).css(\"overflow\"), [\"scroll\", \"auto\"]) !== -1);\n        return horizontally_scrollable;\n    },\n});\n\n// Make Visible in scroll\n$.fn.makeVisibleInScroll = function (parent_id) {\n    var absoluteParent = null;\n    if (typeof parent_id === \"string\") {\n        absoluteParent = $(\"#\" + parent_id);\n    } else if (parent_id) {\n        absoluteParent = $(parent_id);\n    }\n\n    return this.each(function () {\n        var $this = $(this),\n            parent;\n        if (!absoluteParent) {\n            parent = $this.parents(\":scrollable\");\n            if (parent.length > 0) {\n                parent = $(parent[0]);\n            } else {\n                parent = $(window);\n            }\n        } else {\n            parent = absoluteParent;\n        }\n\n        var elemTop = $this.position().top;\n        var elemBottom = $this.height() + elemTop;\n\n        var viewTop = parent.scrollTop();\n        var viewBottom = parent.height() + viewTop;\n\n        if (elemTop < viewTop) {\n            parent.scrollTop(elemTop);\n        } else if (elemBottom > viewBottom - parent.height() / 2) {\n            parent.scrollTop(elemTop - (parent.height() - $this.height()) / 2);\n        }\n    });\n};\n\n//Work around warning for jQuery 3.x:\n//JQMIGRATE: jQuery.fn.offset() requires an element connected to a document\n$.fn.safeOffset = function () {\n    var docElem,\n        elem = this[0],\n        origin = { top: 0, left: 0 };\n\n    if (!elem || !elem.nodeType) {\n        return origin;\n    }\n\n    docElem = (elem.ownerDocument || document).documentElement;\n    if (!$.contains(docElem, elem)) {\n        return origin;\n    }\n\n    return $.fn.offset.apply(this, arguments);\n};\n\n//Make absolute location\n$.fn.setPositionAbsolute = function (element, offsettop, offsetleft) {\n    return this.each(function () {\n        // set absolute location for based on the element passed\n        // dynamically since every browser has different settings\n        var $this = $(this);\n        var thiswidth = $(this).width();\n        var pos = element.safeOffset();\n        var width = element.width();\n        var height = element.height();\n        var setleft = pos.left + width - thiswidth + offsetleft;\n        var settop = pos.top + height + offsettop;\n        $this.css({\n            \"z-index\": 1,\n            \"position\": \"absolute\",\n            \"marginLeft\": 0,\n            \"marginTop\": 0,\n            \"left\": setleft + \"px\",\n            \"top\": settop + \"px\",\n            \"width\": thiswidth,\n        });\n        $this.remove().appendTo(\"body\").show();\n    });\n};\n\n$.fn.positionAncestor = function (selector) {\n    var left = 0;\n    var top = 0;\n    this.each(function () {\n        // check if current element has an ancestor matching a selector\n        // and that ancestor is positioned\n        var $ancestor = $(this).closest(selector);\n        if ($ancestor.length && $ancestor.css(\"position\") !== \"static\") {\n            var $child = $(this);\n            var childMarginEdgeLeft =\n                $child.safeOffset().left - parseInt($child.css(\"marginLeft\"), 10);\n            var childMarginEdgeTop =\n                $child.safeOffset().top - parseInt($child.css(\"marginTop\"), 10);\n            var ancestorPaddingEdgeLeft =\n                $ancestor.safeOffset().left +\n                parseInt($ancestor.css(\"borderLeftWidth\"), 10);\n            var ancestorPaddingEdgeTop =\n                $ancestor.safeOffset().top +\n                parseInt($ancestor.css(\"borderTopWidth\"), 10);\n            left = childMarginEdgeLeft - ancestorPaddingEdgeLeft;\n            top = childMarginEdgeTop - ancestorPaddingEdgeTop;\n            // we have found the ancestor and computed the position\n            // stop iterating\n            return false;\n        }\n    });\n    return {\n        left: left,\n        top: top,\n    };\n};\n\n$.fn.findInclusive = function (selector) {\n    return this.find(\"*\").addBack().filter(selector);\n};\n\n$.fn.slideIn = function (speed, easing, callback) {\n    return this.animate({ width: \"show\" }, speed, easing, callback);\n};\n\n$.fn.slideOut = function (speed, easing, callback) {\n    return this.animate({ width: \"hide\" }, speed, easing, callback);\n};\n\n// case-insensitive :contains\n$.expr[\":\"].Contains = function (a, i, m) {\n    return $(a).text().toUpperCase().indexOf(m[3].toUpperCase()) >= 0;\n};\n\n$.fn.scopedFind = function (selector) {\n    /*  If the selector starts with an object id do a global search,\n     *  otherwise do a local search.\n     */\n    if (selector.indexOf(\"#\") === 0) {\n        return $(selector);\n    } else {\n        return this.find(selector);\n    }\n};\n\nexport default undefined;\n","/**\n * Patterns ajax - AJAX injection for forms and anchors\n *\n * Copyright 2012-2013 Florian Friesdorf\n * Copyright 2012-2013 Marko Durkovic\n */\nimport $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\n\nconst log = logging.getLogger(\"pat.ajax\");\n\nexport const parser = new Parser(\"ajax\");\nparser.addArgument(\"accept\", \"text/html\");\nparser.addArgument(\"url\", function ($el) {\n    return (\n        $el.is(\"a\") ? $el.attr(\"href\") : $el.is(\"form\") ? $el.attr(\"action\") : \"\"\n    ).split(\"#\")[0];\n});\n\n$.ajaxSetup({\n    // Disable caching of AJAX responses\n    cache: false,\n});\n\nvar xhrCount = {};\nxhrCount.get = function (a) {\n    return this[a] !== undefined ? this[a] : 0;\n};\nxhrCount.inc = function (a) {\n    this[a] = this.get(a) + 1;\n    return this.get(a);\n};\n\nvar _ = {\n    name: \"ajax\",\n    trigger: \".pat-ajax\",\n    parser: parser,\n    init: function ($el) {\n        $el.off(\".pat-ajax\");\n        $el.filter(\"a\").on(\"click.pat-ajax\", _.onTriggerEvents);\n        $el.filter(\"form\")\n            .on(\"submit.pat-ajax\", _.onTriggerEvents)\n            .on(\"click.pat-ajax\", \"[type=submit]\", _.onClickSubmit);\n        $el.filter(\":not(form,a)\").each(function () {\n            log.warn(\"Unsupported element:\", this);\n        });\n        return $el;\n    },\n    destroy: function ($el) {\n        $el.off(\".pat-ajax\");\n    },\n    onClickSubmit: function (event) {\n        var $form = $(event.target).parents(\"form\").first(),\n            name = event.target.name,\n            value = $(event.target).val(),\n            data = {};\n        if (name) {\n            data[name] = value;\n        }\n        $form.data(\"pat-ajax.clicked-data\", data);\n    },\n    onTriggerEvents: function (event) {\n        if (event) {\n            event.preventDefault();\n        }\n        _.request($(this));\n    },\n    request: function ($el, opts) {\n        return $el.each(function () {\n            _._request($(this), opts);\n        });\n    },\n    _request: function ($el, opts) {\n        var cfg = _.parser.parse($el, opts),\n            onError = function (jqxhr, status, error) {\n                // error can also stem from a javascript\n                // exception, not only errors described in the\n                // jqxhr.\n                log.error(\"load error for \" + cfg.url + \":\", error, jqxhr);\n                $el.trigger({\n                    type: \"pat-ajax-error\",\n                    jqxhr: jqxhr,\n                });\n            },\n            seqNumber = xhrCount.inc(cfg.url),\n            onSuccess = function (data, status, jqxhr) {\n                log.debug(\"success: jqxhr:\", jqxhr);\n                if (seqNumber === xhrCount.get(cfg.url)) {\n                    // if this url is requested multiple time, only return the last result\n                    $el.trigger({\n                        type: \"pat-ajax-success\",\n                        jqxhr: jqxhr,\n                    });\n                } else {\n                    // ignore\n                }\n            },\n            temp = $el.data(\"pat-ajax.clicked-data\"),\n            clickedData = temp ? $.param(temp) : \"\",\n            args = {\n                context: $el,\n                data: [$el.serialize(), clickedData].filter(Boolean).join(\"&\"),\n                headers: {},\n                url: cfg.url,\n                method: $el.attr(\"method\") ? $el.attr(\"method\") : \"GET\",\n            };\n\n        if (cfg.accept) {\n            args.headers.Accept = cfg.accept;\n        }\n\n        if (\n            $el.is(\"form\") &&\n            $el.attr(\"method\") &&\n            $el.attr(\"method\").toUpperCase() == \"POST\"\n        ) {\n            var formdata = new FormData($el[0]);\n            for (var key in temp) {\n                formdata.append(key, temp[key]);\n            }\n            args[\"method\"] = \"POST\";\n            args[\"data\"] = formdata;\n            args[\"cache\"] = false;\n            args[\"contentType\"] = false;\n            args[\"processData\"] = false;\n            args[\"type\"] = \"POST\";\n        }\n\n        $el.removeData(\"pat-ajax.clicked-data\");\n        log.debug(\"request:\", args, $el[0]);\n\n        // Make it happen\n        var ajax_deferred = $.ajax(args);\n\n        if (ajax_deferred) ajax_deferred.done(onSuccess).fail(onError);\n    },\n};\n\nregistry.register(_);\n\nexport default _;\n","import \"../../core/jquery-ext\"; // for :scrollable for autoLoading-visible\nimport \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport $ from \"jquery\";\nimport _ from \"underscore\";\nimport ajax from \"../ajax/ajax\";\nimport dom from \"../../core/dom\";\nimport logging from \"../../core/logging\";\nimport Parser from \"../../core/parser\";\nimport registry from \"../../core/registry\";\nimport utils from \"../../core/utils\";\n\nconst log = logging.getLogger(\"pat.inject\");\nconst TEXT_NODE = 3;\nconst COMMENT_NODE = 8;\n\nexport const parser = new Parser(\"inject\");\nparser.addArgument(\"default-selector\");\nparser.addArgument(\"target\");\nparser.addArgument(\"data-type\", \"html\");\nparser.addArgument(\"next-href\");\nparser.addArgument(\"source\");\nparser.addArgument(\"trigger\", \"default\", [\n    \"default\",\n    \"autoload\",\n    \"autoload-visible\",\n    \"idle\",\n]);\nparser.addArgument(\"delay\"); // only used in autoload\nparser.addArgument(\"confirm\", \"class\", [\"never\", \"always\", \"form-data\", \"class\"]);\nparser.addArgument(\"confirm-message\", \"Are you sure you want to leave this page?\");\nparser.addArgument(\"hooks\", [], [\"raptor\"], true); // After injection, pat-inject will trigger an event for each hook: pat-inject-hook-$(hook)\nparser.addArgument(\"loading-class\", \"injecting\"); // Add a class to the target while content is still loading.\nparser.addArgument(\"executing-class\", \"executing\"); // Add a class to the element while content is still loading.\nparser.addArgument(\"executed-class\", \"executed\"); // Add a class to the element when content is loaded.\nparser.addArgument(\"class\"); // Add a class to the injected content.\nparser.addArgument(\"history\");\nparser.addArgument(\"push-marker\");\nparser.addArgument(\"scroll\");\n// XXX: this should not be here but the parser would bail on\n// unknown parameters and expand/collapsible need to pass the url\n// to us\nparser.addArgument(\"url\");\n\nconst inject = {\n    name: \"inject\",\n    trigger:\n        \".raptor-ui .ui-button.pat-inject, a.pat-inject, form.pat-inject, .pat-subform.pat-inject\",\n    parser: parser,\n\n    init($el, opts) {\n        const cfgs = this.extractConfig($el, opts);\n        if (cfgs.some((e) => e.history === \"record\") && !(\"pushState\" in history)) {\n            // if the injection shall add a history entry and HTML5 pushState\n            // is missing, then don't initialize the injection.\n            return $el;\n        }\n        $el.data(\"pat-inject\", cfgs);\n\n        if (cfgs[0].nextHref && cfgs[0].nextHref.indexOf(\"#\") === 0) {\n            // In case the next href is an anchor, and it already\n            // exists in the page, we do not activate the injection\n            // but instead just change the anchors href.\n\n            // XXX: This is used in only one project for linked\n            // fullcalendars, it's sanity is wonky and we should\n            // probably solve it differently.\n            if ($el.is(\"a\") && $(cfgs[0].nextHref).length > 0) {\n                log.debug(\n                    \"Skipping as next href is anchor, which already exists\",\n                    cfgs[0].nextHref\n                );\n                // XXX: reconsider how the injection enters exhausted state\n                return $el.attr({\n                    href: (window.location.href.split(\"#\")[0] || \"\") + cfgs[0].nextHref,\n                });\n            }\n        }\n        if (cfgs[0].pushMarker) {\n            $(\"body\").on(\"push\", (event, data) => {\n                log.debug(\"received push message: \" + data);\n                if (data == cfgs[0].pushMarker) {\n                    log.debug(\"re-injecting \" + data);\n                    this.onTrigger({ currentTarget: $el[0] });\n                }\n            });\n        }\n        if (cfgs[0].idleTrigger) {\n            this._initIdleTrigger($el, cfgs[0].idleTrigger);\n        } else {\n            switch (cfgs[0].trigger) {\n                case \"default\":\n                    cfgs.forEach((cfg) => {\n                        if (cfg.delay) {\n                            cfg.processDelay = cfg.delay;\n                        }\n                    });\n                    // setup event handlers\n                    if ($el.is(\"form\")) {\n                        $el.on(\"submit.pat-inject\", this.onTrigger.bind(this))\n                            .on(\"click.pat-inject\", \"[type=submit]\", ajax.onClickSubmit)\n                            .on(\n                                \"click.pat-inject\",\n                                \"[type=submit][formaction], [type=image][formaction]\",\n                                this.onFormActionSubmit.bind(this)\n                            );\n                    } else if ($el.is(\".pat-subform\")) {\n                        log.debug(\"Initializing subform with injection\");\n                    } else {\n                        $el.on(\"click.pat-inject\", this.onTrigger.bind(this));\n                    }\n                    break;\n                case \"autoload\":\n                    if (!cfgs[0].delay) {\n                        this.onTrigger({ currentTarget: $el[0] });\n                    } else {\n                        // generate UID\n                        const uid = Math.random().toString(36);\n                        $el.attr(\"data-pat-inject-uid\", uid);\n\n                        // function to trigger the autoload and mark as triggered\n                        const delayed_trigger = (uid_) => {\n                            // Check if the element has been removed from the dom\n                            const still_there = $(\n                                \"[data-pat-inject-uid='\" + uid_ + \"']\"\n                            );\n                            if (still_there.length == 0) return false;\n\n                            $el.data(\"pat-inject-autoloaded\", true);\n                            this.onTrigger({ currentTarget: $el[0] });\n                            return true;\n                        };\n                        window.setTimeout(\n                            delayed_trigger.bind(null, uid),\n                            cfgs[0].delay\n                        );\n                    }\n                    break;\n                case \"autoload-visible\":\n                    this._initAutoloadVisible($el, cfgs);\n                    break;\n                case \"idle\":\n                    this._initIdleTrigger($el, cfgs[0].delay);\n                    break;\n            }\n        }\n\n        log.debug(\"initialised:\", $el);\n        return $el;\n    },\n\n    destroy($el) {\n        $el.off(\".pat-inject\");\n        $el.data(\"pat-inject\", null);\n        return $el;\n    },\n\n    onTrigger(e) {\n        /* Injection has been triggered, either via form submission or a\n         * link has been clicked.\n         */\n        const $el = $(e.currentTarget);\n        const cfgs = $el.data(\"pat-inject\");\n        if ($el.is(\"form\")) {\n            $(cfgs).each((i, v) => {\n                v.params = $.param($el.serializeArray());\n            });\n        }\n        e.preventDefault && e.preventDefault();\n        $el.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $el);\n    },\n\n    onFormActionSubmit(e) {\n        ajax.onClickSubmit(e); // make sure the submitting button is sent with the form\n\n        const $button = $(e.target);\n        const formaction = $button.attr(\"formaction\");\n        const $form = $button.parents(\".pat-inject\").first();\n        const opts = {\n            url: formaction,\n        };\n        const $cfg_node = $button.closest(\"[data-pat-inject]\");\n        const cfgs = this.extractConfig($cfg_node, opts);\n\n        $(cfgs).each((i, v) => {\n            v.params = $.param($form.serializeArray());\n        });\n\n        e.preventDefault();\n        $form.trigger(\"patterns-inject-triggered\");\n        this.execute(cfgs, $form);\n    },\n\n    submitSubform($sub) {\n        /* This method is called from pat-subform\n         */\n        const $el = $sub.parents(\"form\");\n        const cfgs = $sub.data(\"pat-inject\");\n\n        // store the params of the subform in the config, to be used by history\n        $(cfgs).each((i, v) => {\n            v.params = $.param($sub.serializeArray());\n        });\n\n        try {\n            $el.trigger(\"patterns-inject-triggered\");\n        } catch (e) {\n            log.error(\"patterns-inject-triggered\", e);\n        }\n        this.execute(cfgs, $el);\n    },\n\n    extractConfig($el, opts) {\n        opts = $.extend({}, opts);\n\n        const cfgs = parser.parse($el, opts, true);\n        cfgs.forEach((cfg) => {\n            cfg.$context = $el;\n            // opts and cfg have priority, fall back to href/action\n            cfg.url =\n                opts.url ||\n                cfg.url ||\n                $el.attr(\"href\") ||\n                $el.attr(\"action\") ||\n                $el.parents(\"form\").attr(\"action\") ||\n                \"\";\n\n            // separate selector from url\n            const urlparts = cfg.url.split(\"#\");\n            cfg.url = urlparts[0];\n\n            if (urlparts.length > 2) {\n                log.warn(\"Ignoring additional source ids:\", urlparts.slice(2));\n            }\n\n            if (!cfg.defaultSelector) {\n                // if no selector, check for selector as part of original url\n                cfg.defaultSelector = (urlparts[1] && \"#\" + urlparts[1]) || \"body\";\n            }\n            if (cfg.delay) {\n                try {\n                    cfg.delay = utils.parseTime(cfg.delay);\n                } catch (e) {\n                    log.warn(\"Invalid delay value: \", cfg.delay);\n                    cfg.delay = null;\n                }\n            }\n            cfg.processDelay = 0;\n        });\n        return cfgs;\n    },\n\n    elementIsDirty(m) {\n        /* Check whether the passed in form element contains a value.\n         */\n        const data = $.map(m.find(\":input:not(select)\"), (i) => {\n            const val = $(i).val();\n            return Boolean(val) && val !== $(i).attr(\"placeholder\");\n        });\n        return $.inArray(true, data) !== -1;\n    },\n\n    askForConfirmation(cfgs) {\n        /* If configured to do so, show a confirmation dialog to the user.\n         * This is done before attempting to perform injection.\n         */\n        let should_confirm = false;\n        let message;\n\n        _.each(cfgs, (cfg) => {\n            let _confirm = false;\n            if (cfg.confirm == \"always\") {\n                _confirm = true;\n            } else if (cfg.confirm === \"form-data\") {\n                if (cfg.target != \"none\") _confirm = this.elementIsDirty(cfg.$target);\n            } else if (cfg.confirm === \"class\") {\n                if (cfg.target != \"none\") _confirm = cfg.$target.hasClass(\"is-dirty\");\n            }\n            if (_confirm) {\n                should_confirm = true;\n                message = cfg.confirmMessage;\n            }\n        });\n        if (should_confirm) {\n            if (!window.confirm(message)) {\n                return false;\n            }\n        }\n        return true;\n    },\n\n    ensureTarget(cfg) {\n        /* Make sure that a target element exists and that it's assigned to\n         * cfg.$target.\n         */\n        // make sure target exist\n        if (cfg.target === \"none\") {\n            // special case, we don't want to inject anything\n            return true;\n        }\n        cfg.$target =\n            cfg.$target || (cfg.target === \"self\" ? cfg.$context : $(cfg.target));\n        if (cfg.$target.length === 0) {\n            if (!cfg.target) {\n                log.error(\"Need target selector\", cfg);\n                return false;\n            }\n            cfg.$target = this.createTarget(cfg.target);\n            cfg.$injected = cfg.$target;\n        }\n        return true;\n    },\n\n    verifySingleConfig(url, cfg) {\n        /* Verify one of potentially multiple configs (i.e. argument lists).\n         *\n         * Extract modifiers such as ::element or ::after.\n         * Ensure that a target element exists.\n         */\n        if (cfg.url !== url) {\n            // in case of multi-injection, all injections need to use\n            // the same url\n            log.error(\"Unsupported different urls for multi-inject\");\n            return false;\n        }\n        // defaults\n        cfg.source = cfg.source || cfg.defaultSelector;\n        cfg.target = cfg.target || cfg.defaultSelector;\n\n        if (!this.extractModifiers(cfg)) {\n            return false;\n        }\n        if (!this.ensureTarget(cfg)) {\n            return false;\n        }\n        this.listenForFormReset(cfg);\n        return true;\n    },\n\n    verifyConfig(cfgs) {\n        /* Verify and post-process all the configurations.\n         * Each \"config\" is an arguments list separated by the &&\n         * combination operator.\n         *\n         * In case of multi-injection, only one URL is allowed, which\n         * should be specified in the first config (i.e. arguments list).\n         *\n         * Verification for each cfg in the array needs to succeed.\n         */\n        return cfgs.every(_.partial(this.verifySingleConfig.bind(this), cfgs[0].url));\n    },\n\n    listenForFormReset(cfg) {\n        /* if pat-inject is used to populate target in some form and when\n         * Cancel button is pressed (this triggers reset event on the\n         * form) you would expect to populate with initial placeholder\n         */\n        if (cfg.target === \"none\")\n            // Special case, we don't want to display any return value.\n            return;\n        const $form = cfg.$target.parents(\"form\");\n        if ($form.length !== 0 && cfg.$target.data(\"initial-value\") === undefined) {\n            cfg.$target.data(\"initial-value\", cfg.$target.html());\n            $form.on(\"reset\", () => {\n                cfg.$target.html(cfg.$target.data(\"initial-value\"));\n            });\n        }\n    },\n\n    extractModifiers(cfg) {\n        /* The user can add modifiers to the source and target arguments.\n         * Modifiers such as ::element, ::before and ::after.\n         * We identifiy and extract these modifiers here.\n         */\n        const source_re = /^(.*?)(::element)?$/;\n        const target_re = /^(.*?)(::element)?(::after|::before)?$/;\n        const source_match = source_re.exec(cfg.source);\n        const target_match = target_re.exec(cfg.target);\n\n        cfg.source = source_match[1];\n        cfg.sourceMod = source_match[2] ? \"element\" : \"content\";\n        cfg.target = target_match[1];\n        const targetMod = target_match[2] ? \"element\" : \"content\";\n        const targetPosition = (target_match[3] || \"::\").slice(2); // position relative to target\n\n        if (cfg.loadingClass) {\n            cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetMod;\n            if (targetPosition && cfg.loadingClass) {\n                cfg.loadingClass += \" \" + cfg.loadingClass + \"-\" + targetPosition;\n            }\n        }\n        cfg.action = targetMod + targetPosition;\n        // Once we start detecting illegal combinations, we'll\n        // return false in case of error\n        return true;\n    },\n\n    createTarget(selector) {\n        /* create a target that matches the selector\n         *\n         * XXX: so far we only support #target and create a div with\n         * that id appended to the body.\n         */\n        if (selector.slice(0, 1) !== \"#\") {\n            log.error(\"only id supported for non-existing target\");\n            return null;\n        }\n        const $target = $(\"<div />\").attr({ id: selector.slice(1) });\n        $(\"body\").append($target);\n        return $target;\n    },\n\n    stopBubblingFromRemovedElement($el, cfgs, ev) {\n        /* IE8 fix. Stop event from propagating IF $el will be removed\n         * from the DOM. With pat-inject, often $el is the target that\n         * will itself be replaced with injected content.\n         *\n         * IE8 cannot handle events bubbling up from an element removed\n         * from the DOM.\n         *\n         * See: http://stackoverflow.com/questions/7114368/why-is-jquery-remove-throwing-attr-exception-in-ie8\n         */\n        for (const cfg of cfgs) {\n            const sel = cfg.target;\n            if ($el.parents(sel).addBack(sel) && !ev.isPropagationStopped()) {\n                ev.stopPropagation();\n                return;\n            }\n        }\n    },\n\n    _performInjection(target, $el, $source, cfg, trigger, title) {\n        /* Called after the XHR has succeeded and we have a new $source\n         * element to inject.\n         */\n        if (cfg.sourceMod === \"content\") {\n            $source = $source.contents();\n        }\n        let $src;\n        // $source.clone() does not work with shived elements in IE8\n        if (document.all && document.querySelector && !document.addEventListener) {\n            $src = $source.map((idx, el) => $(el.outerHTML)[0]);\n        } else {\n            $src = $source.safeClone();\n        }\n\n        $src.findInclusive(\"img\").on(\"load\", (e) => {\n            $(e.currentTarget).trigger(\"pat-inject-content-loaded\");\n        });\n\n        const $injected = cfg.$injected || $src;\n        // Now the injection actually happens.\n        if (this._inject(trigger, $src, $(target), cfg)) {\n            this._afterInjection($el, $injected, cfg);\n        }\n        // History support. if subform is submitted, append form params\n        const glue = cfg.url.indexOf(\"?\") > -1 ? \"&\" : \"?\";\n        if (cfg.history === \"record\" && \"pushState\" in history) {\n            if (cfg.params) {\n                history.pushState(\n                    { url: cfg.url + glue + cfg.params },\n                    \"\",\n                    cfg.url + glue + cfg.params\n                );\n            } else {\n                history.pushState({ url: cfg.url }, \"\", cfg.url);\n            }\n            // Also inject title element if we have one\n            if (title)\n                this._inject(trigger, title, $(\"title\"), {\n                    action: \"element\",\n                });\n        }\n    },\n\n    _afterInjection($el, $injected, cfg) {\n        /* Set a class on the injected elements and fire the\n         * patterns-injected event.\n         */\n        $injected\n            .filter((idx, el_) => {\n                // setting data on textnode fails in IE8\n                return el_.nodeType !== TEXT_NODE;\n            })\n            .data(\"pat-injected\", { origin: cfg.url });\n\n        if ($injected.length === 1 && $injected[0].nodeType == TEXT_NODE) {\n            // Only one element injected, and it was a text node.\n            // So we trigger \"patterns-injected\" on the parent.\n            // The event handler should check whether the\n            // injected element and the triggered element are\n            // the same.\n            $injected.parent().trigger(\"patterns-injected\", [cfg, $el[0], $injected[0]]);\n        } else {\n            $injected.each((idx, el_) => {\n                // patterns-injected event will be triggered for each injected (non-text) element.\n                if (el_.nodeType !== TEXT_NODE) {\n                    $(el_)\n                        .addClass(cfg[\"class\"])\n                        .trigger(\"patterns-injected\", [cfg, $el[0], el_]);\n                }\n            });\n        }\n\n        if (cfg.scroll && cfg.scroll !== \"none\") {\n            let scroll_container = cfg.$target.parents().addBack().filter(\":scrollable\");\n            scroll_container = scroll_container.length ? scroll_container[0] : window;\n\n            // default for scroll===top\n            let top = 0;\n            let left = 0;\n\n            if (cfg.scroll !== \"top\") {\n                const scroll_target =\n                    cfg.scroll === \"target\"\n                        ? cfg.$target[0]\n                        : $injected.filter(cfg.scroll)[0];\n\n                // Get the reference element to which against we calculate\n                // the relative position of the target.\n                // In case of a scroll container of window, we do not have\n                // getBoundingClientRect method, so get the body instead.\n                const scroll_container_ref =\n                    scroll_container === window ? document.body : scroll_container;\n\n                // Calculate absolute [¹] position difference between\n                // scroll_container and scroll_target.\n                // Substract the container's border from the scrolling\n                // value, as this one isn't respected by\n                // getBoundingClientRect [²] and would lead to covered\n                // items [³].\n                // ¹) so that it doesn't make a difference, if the element\n                // is below or above the scrolling container. We just need\n                // to know the absolute difference.\n                // ²) Calculations are based from the viewport.\n                // ³) See:\n                //      https://docs.microsoft.com/en-us/previous-versions//hh781509(v=vs.85)\n                //      https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect\n                left = Math.abs(\n                    scroll_target.getBoundingClientRect().left +\n                        scroll_container_ref.scrollLeft -\n                        scroll_container_ref.getBoundingClientRect().left -\n                        utils.getCSSValue(\n                            scroll_container_ref,\n                            \"border-left-width\",\n                            true\n                        )\n                );\n                top = Math.abs(\n                    scroll_target.getBoundingClientRect().top +\n                        scroll_container_ref.scrollTop -\n                        scroll_container_ref.getBoundingClientRect().top -\n                        utils.getCSSValue(scroll_container_ref, \"border-top-width\", true)\n                );\n            }\n            if (scroll_container === window) {\n                scroll_container.scrollTo(left, top);\n            } else {\n                scroll_container.scrollLeft = left;\n                scroll_container.scrollTop = top;\n            }\n        }\n\n        $el[0].dispatchEvent(\n            new Event(\"pat-inject-success\", { bubbles: true, cancelable: true })\n        );\n    },\n\n    async _onInjectSuccess($el, cfgs, ev) {\n        let data = ev && ev.jqxhr && ev.jqxhr.responseText;\n        if (!data) {\n            log.warn(\"No response content, aborting\", ev);\n            return;\n        }\n        if (cfgs[0].source === \"none\") {\n            // Special case, we want to call something, but we don't want to inject anything\n            data = \"\";\n        }\n        $.each(cfgs[0].hooks || [], (idx, hook) =>\n            $el.trigger(\"pat-inject-hook-\" + hook)\n        );\n        this.stopBubblingFromRemovedElement($el, cfgs, ev);\n        const sources$ = await this.callTypeHandler(cfgs[0].dataType, \"sources\", $el, [\n            cfgs,\n            data,\n            ev,\n        ]);\n        /* pick the title source for dedicated handling later\n          Title - if present - is always appended at the end. */\n        let title;\n        if (\n            sources$ &&\n            sources$[sources$.length - 1] &&\n            sources$[sources$.length - 1][0] &&\n            sources$[sources$.length - 1][0].nodeName == \"TITLE\"\n        ) {\n            title = sources$[sources$.length - 1];\n        }\n        cfgs.forEach((cfg, idx1) => {\n            const perform_inject = () => {\n                if (cfg.target != \"none\")\n                    cfg.$target.each((idx2, target) => {\n                        this._performInjection(\n                            target,\n                            $el,\n                            sources$[idx1],\n                            cfg,\n                            ev.target,\n                            title\n                        );\n                    });\n            };\n            if (cfg.processDelay) {\n                setTimeout(() => perform_inject(), cfg.processDelay);\n            } else {\n                perform_inject();\n            }\n        });\n        if (cfgs[0].nextHref && $el.is(\"a\")) {\n            // In case next-href is specified the anchor's href will\n            // be set to it after the injection is triggered.\n            $el.attr({ href: cfgs[0].nextHref.replace(/&amp;/g, \"&\") });\n            this.destroy($el);\n        }\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n    },\n\n    async _onInjectError($el, cfgs, event) {\n        let explanation = \"\";\n        const status = event.jqxhr.status;\n        const timestamp = new Date();\n        if (status % 100 == 4) {\n            explanation =\n                \"Sorry! We couldn't find the page to load. Please make a screenshot and send it to support. Thank you!\";\n        } else if (status % 100 == 5) {\n            explanation =\n                \"I am very sorry! There was an error at the server. Please make a screenshot and contact support. Thank you!\";\n        } else if (status == 0) {\n            explanation =\n                \"It seems, the server is down. Please make a screenshot and contact support. Thank you!\";\n        }\n\n        let error_page;\n        let error_page_fragment;\n        const url_params = new URLSearchParams(window.location.search);\n        if (url_params.get(\"pat-inject-errorhandler.off\") === null) {\n            // Prepare a error page to be injected into the document.\n\n            // Try to get a suitable error message from pre-configured error pages.\n            const error_page_url = document\n                .querySelector(`meta[name^=pat-inject-status-${status}]`)\n                ?.getAttribute(\"content\", false);\n            error_page_fragment = error_page_url?.split(\"#\")[1];\n            error_page_fragment = error_page_fragment ? `#${error_page_fragment}` : null;\n\n            if (error_page_fragment) {\n                error_page = document.createElement(\"html\");\n                error_page.innerHTML = event.jqxhr.responseText;\n                error_page = error_page.querySelector(error_page_fragment);\n            }\n\n            if (!error_page && error_page_url) {\n                try {\n                    const error_page_response = await fetch(error_page_url, {\n                        method: \"GET\",\n                    });\n                    error_page = document.createElement(\"html\");\n                    error_page.innerHTML = await error_page_response.text();\n                    error_page = error_page.querySelector(error_page_fragment || \"body\");\n                } catch {\n                    // fall back to standard error message and ignore.\n                }\n            }\n        }\n\n        // clean up\n        cfgs.forEach((cfg) => {\n            if (\"$injected\" in cfg) {\n                cfg.$injected.remove();\n            }\n            cfg.$target.removeClass(cfg.loadingClass);\n            $el.removeClass(cfg.executingClass);\n        });\n        $el.off(\"pat-ajax-success.pat-inject\");\n        $el.off(\"pat-ajax-error.pat-inject\");\n\n        if (error_page) {\n            const error_zone = document.querySelector(error_page_fragment || \"body\");\n            error_zone.innerHTML = error_page.innerHTML;\n            registry.scan(error_zone); // initialize any patterns in error page\n        } else {\n            const msg_attr = `${explanation} Status is ${status} ${event.jqxhr.statusText}, time was ${timestamp}. You can click to close this.`;\n            $(\"body\").attr(\"data-error-message\", msg_attr);\n            $(\"body\").on(\"click\", () => {\n                $(\"body\").removeAttr(\"data-error-message\");\n                window.location.href = window.location.href; // reload\n            });\n        }\n    },\n\n    execute(cfgs, $el) {\n        /* Actually execute the injection.\n         *\n         * Either by making an ajax request or by spoofing an ajax\n         * request when the content is readily available in the current page.\n         */\n        // get a kinda deep copy, we scribble on it\n        cfgs = cfgs.map((cfg) => $.extend({}, cfg));\n        if (!this.verifyConfig(cfgs)) {\n            return;\n        }\n        if (!this.askForConfirmation(cfgs)) {\n            return;\n        }\n        if ($el.data(\"pat-inject-triggered\")) {\n            // Prevent double triggers;\n            return;\n        }\n        $el.data(\"pat-inject-triggered\", true);\n        // possibility for spinners on targets\n        _.chain(cfgs)\n            .filter(_.property(\"loadingClass\"))\n            .each((cfg) => {\n                if (cfg.target != \"none\") cfg.$target.addClass(cfg.loadingClass);\n            });\n        // Put the execute class on the elem that has pat inject on it\n        _.chain(cfgs)\n            .filter(_.property(\"loadingClass\"))\n            .each((cfg) => $el.addClass(cfg.executingClass));\n\n        $el.on(\n            \"pat-ajax-success.pat-inject\",\n            this._onInjectSuccess.bind(this, $el, cfgs)\n        );\n        $el.on(\"pat-ajax-error.pat-inject\", this._onInjectError.bind(this, $el, cfgs));\n        $el.on(\"pat-ajax-success.pat-inject pat-ajax-error.pat-inject\", () =>\n            $el.removeData(\"pat-inject-triggered\")\n        );\n\n        if (cfgs[0].url.length) {\n            ajax.request($el, { url: cfgs[0].url });\n        } else {\n            // If there is no url specified, then content is being fetched\n            // from the same page.\n            // No need to do an ajax request for this, so we spoof the ajax\n            // event.\n            $el.trigger({\n                type: \"pat-ajax-success\",\n                jqxhr: {\n                    responseText: $(\"body\").html(),\n                },\n            });\n        }\n    },\n\n    _inject(trigger, $source, $target, cfg) {\n        // action to jquery method mapping, except for \"content\"\n        // and \"element\"\n        const method = {\n            contentbefore: \"prepend\",\n            contentafter: \"append\",\n            elementbefore: \"before\",\n            elementafter: \"after\",\n        }[cfg.action];\n\n        if (cfg.source === \"none\") {\n            $target.replaceWith(\"\");\n            return true;\n        }\n        if ($source.length === 0) {\n            log.warn(\"Aborting injection, source not found:\", $source);\n            $(trigger).trigger(\"pat-inject-missingSource\", {\n                url: cfg.url,\n                selector: cfg.source,\n            });\n            return false;\n        }\n        if (cfg.target === \"none\")\n            // Special case. Don't do anything, we don't want any result\n            return true;\n        if ($target.length === 0) {\n            log.warn(\"Aborting injection, target not found:\", $target);\n            $(trigger).trigger(\"pat-inject-missingTarget\", {\n                selector: cfg.target,\n            });\n            return false;\n        }\n        if (cfg.action === \"content\") {\n            $target.empty().append($source);\n        } else if (cfg.action === \"element\") {\n            $target.replaceWith($source);\n        } else {\n            $target[method]($source);\n        }\n        return true;\n    },\n\n    _sourcesFromHtml(html, url, sources) {\n        const $html = this._parseRawHtml(html, url);\n        return sources.map((source) => {\n            if (source === \"body\") {\n                source = \"#__original_body\";\n            }\n            if (source === \"none\") {\n                return $(\"<!-- -->\");\n            }\n            const $source = $html.find(source);\n\n            if ($source.length === 0) {\n                if (source != \"title\") {\n                    log.warn(\"No source elements for selector:\", source, $html);\n                }\n            }\n\n            $source.find('a[href^=\"#\"]').each((idx, el_) => {\n                const href = el_.getAttribute(\"href\");\n                if (href.indexOf(\"#{1}\") !== -1) {\n                    // We ignore hrefs containing #{1} because they're not\n                    // valid and only applicable in the context of\n                    // pat-clone.\n                    return;\n                }\n                // Skip in-document links pointing to an id that is inside\n                // this fragment.\n                if (href.length === 1) {\n                    // Special case for top-of-page links\n                    el_.href = url;\n                } else if (!$source.find(href).length) {\n                    el_.href = url + href;\n                }\n            });\n            return $source;\n        });\n    },\n\n    _rebaseAttrs: {\n        A: \"href\",\n        FORM: \"action\",\n        IMG: \"data-pat-inject-rebase-src\",\n        OBJECT: \"data\",\n        SOURCE: \"data-pat-inject-rebase-src\",\n        VIDEO: \"data-pat-inject-rebase-src\",\n    },\n\n    _rebaseOptions: {\n        \"calendar\": [\"url\", \"event-sources\"],\n        \"collapsible\": [\"load-content\"],\n        \"date-picker\": [\"i18n\"],\n        \"datetime-picker\": [\"i18n\"],\n        \"inject\": [\"url\"],\n    },\n\n    _rebaseHTML(base, html) {\n        if (html === \"\") {\n            // Special case, source is none\n            return \"\";\n        }\n        const $page = $(\n            html.replace(/(\\s)(src\\s*)=/gi, '$1src=\"\" data-pat-inject-rebase-$2=').trim()\n        )\n            .wrapAll(\"<div>\")\n            .parent();\n\n        $page.find(Object.keys(this._rebaseAttrs).join(\",\")).each((idx, el_) => {\n            const $el_ = $(el_);\n            const attrName = this._rebaseAttrs[el_.tagName];\n            let value = $el_.attr(attrName);\n\n            if (\n                value &&\n                value.slice(0, 2) !== \"@@\" &&\n                value[0] !== \"#\" &&\n                value.slice(0, 7) !== \"mailto:\" &&\n                value.slice(0, 4) !== \"tel:\" &&\n                value.slice(0, 4) !== \"fax:\" &&\n                value.slice(0, 7) !== \"callto:\" &&\n                value.slice(0, 10) !== \"ts3server:\" &&\n                value.slice(0, 6) !== \"teams:\" &&\n                value.slice(0, 11) !== \"javascript:\"\n            ) {\n                value = utils.rebaseURL(base, value);\n                $el_.attr(attrName, value);\n            }\n        });\n\n        for (const [pattern_name, opts] of Object.entries(this._rebaseOptions)) {\n            for (const el_ of dom.querySelectorAllAndMe(\n                $page[0],\n                `[data-pat-${pattern_name}]`\n            )) {\n                const pattern = registry.patterns?.[pattern_name];\n                const pattern_parser = pattern?.parser;\n                if (!pattern_parser) {\n                    continue;\n                }\n                // parse: no default options, possibly multiple configs, no grouping.\n                const options = pattern_parser.parse(el_, {}, true, false, false);\n                let changed = false;\n                for (const config of options) {\n                    for (const opt of opts) {\n                        const val = config[opt];\n                        if (!val) {\n                            continue;\n                        }\n                        changed = true;\n                        if (Array.isArray(val)) {\n                            config[opt] = val.map((it) => utils.rebaseURL(base, it));\n                        } else {\n                            config[opt] = utils.rebaseURL(base, val);\n                        }\n                    }\n                }\n                if (changed) {\n                    el_.setAttribute(\n                        `data-pat-${pattern_name}`,\n                        JSON.stringify(options.length === 1 ? options[0] : options)\n                    );\n                }\n            }\n        }\n\n        // XXX: IE8 changes the order of attributes in html. The following\n        // lines move data-pat-inject-rebase-src to src.\n        $page.find(\"[data-pat-inject-rebase-src]\").each((id, el_) => {\n            const $el = $(el_);\n            $el.attr(\"src\", $el.attr(\"data-pat-inject-rebase-src\")).removeAttr(\n                \"data-pat-inject-rebase-src\"\n            );\n        });\n\n        return $page\n            .html()\n            .replace(/src=\"\" data-pat-inject-rebase-/g, \"\")\n            .trim();\n    },\n\n    _parseRawHtml(html, url) {\n        url = url || \"\";\n\n        // remove script tags and head and replace body by a div\n        const title = html.match(/\\<title\\>(.*)\\<\\/title\\>/);\n        let clean_html = html\n            .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\")\n            .replace(/<head\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/head>/gi, \"\")\n            .replace(/<body([^>]*?)>/gi, '<div id=\"__original_body\">')\n            .replace(/<\\/body([^>]*?)>/gi, \"</div>\");\n        if (title && title.length == 2) {\n            clean_html = title[0] + clean_html;\n        }\n        try {\n            clean_html = this._rebaseHTML(url, clean_html);\n        } catch (e) {\n            log.error(\"Error rebasing urls\", e);\n        }\n        const $html = $(\"<div/>\").html(clean_html);\n        if ($html.children().length === 0) {\n            log.warn(\"Parsing html resulted in empty jquery object:\", clean_html);\n        }\n        return $html;\n    },\n\n    // XXX: hack\n    _initAutoloadVisible($el, cfgs) {\n        if ($el.data(\"pat-inject-autoloaded\")) {\n            // ignore executed autoloads\n            return false;\n        }\n        const $scrollable = $el.parents(\":scrollable\");\n\n        // function to trigger the autoload and mark as triggered\n        const trigger = (event) => {\n            if ($el.data(\"pat-inject-autoloaded\")) {\n                return false;\n            }\n            $el.data(\"pat-inject-autoloaded\", true);\n            this.onTrigger({ currentTarget: $el[0] });\n            event && event.preventDefault();\n            return true;\n        };\n        $el.click(trigger);\n\n        // Use case 1: a (heigh-constrained) scrollable parent\n        if ($scrollable.length) {\n            // if scrollable parent and visible -> trigger it\n            // we only look at the closest scrollable parent, no nesting\n            // Check visibility for scrollable\n            const checkVisibility = utils.debounce(() => {\n                if ($el.data(\"patterns.autoload\") || !$.contains(document, $el[0])) {\n                    return false;\n                }\n                if (!$el.is(\":visible\")) {\n                    return false;\n                }\n                if (!utils.elementInViewport($el[0])) {\n                    return false;\n                }\n                // check if the target element still exists. Otherwise halt and catch fire\n                const target = (\n                    $el.data(\"pat-inject\")[0].target || cfgs[0].defaultSelector\n                ).replace(/::element/, \"\");\n                if (target && target !== \"self\" && $(target).length === 0) {\n                    return false;\n                }\n\n                // checkVisibility was possibly installed as a scroll\n                // handler and has now served its purpose -> remove\n                $($scrollable[0]).off(\"scroll\", checkVisibility);\n                $(window).off(\"resize.pat-autoload\", checkVisibility);\n                return trigger();\n            }, 100);\n            if (checkVisibility()) {\n                return true;\n            }\n            // wait to become visible - again only immediate scrollable parent\n            $($scrollable[0]).on(\"scroll\", checkVisibility);\n            $(window).on(\"resize.pat-autoload\", checkVisibility);\n        } else {\n            // Use case 2: scrolling the entire page\n            // Check visibility for non-scrollable\n            const checkVisibility = utils.debounce(() => {\n                if ($el.parents(\":scrollable\").length) {\n                    // Because of a resize the element has now a scrollable parent\n                    // and we should reset the correct event\n                    $(window).off(\".pat-autoload\", checkVisibility);\n                    return this._initAutoloadVisible($el);\n                }\n                if ($el.data(\"patterns.autoload\")) {\n                    return false;\n                }\n                if (!$el.is(\":visible\")) {\n                    return false;\n                }\n                if (!utils.elementInViewport($el[0])) {\n                    return false;\n                }\n                // check if the target element still exists. Otherwise halt and catch fire\n                const target = (\n                    $el.data(\"pat-inject\")[0].target || cfgs[0].defaultSelector\n                ).replace(/::element/, \"\");\n                if (target && target !== \"self\" && $(target).length === 0) {\n                    return false;\n                }\n                $(window).off(\".pat-autoload\", checkVisibility);\n                return trigger();\n            }, 100);\n            if (checkVisibility()) {\n                return true;\n            }\n            // https://github.com/w3c/IntersectionObserver/tree/master/polyfill\n            if (IntersectionObserver) {\n                const observer = new IntersectionObserver(checkVisibility);\n                $el.each((idx, el) => observer.observe(el));\n            } else {\n                $(window).on(\"resize.pat-autoload scroll.pat-autoload\", checkVisibility);\n            }\n        }\n        return false;\n    },\n\n    _initIdleTrigger($el, delay) {\n        // XXX TODO: handle item removed from DOM\n        const timeout = parseInt(delay, 10);\n        let timer;\n\n        const onTimeout = () => {\n            this.onTrigger({ currentTarget: $el[0] });\n            unsub();\n            clearTimeout(timer);\n        };\n\n        const onInteraction = utils.debounce(() => {\n            if (!document.body.contains($el[0])) {\n                unsub();\n                return;\n            }\n            clearTimeout(timer);\n            timer = setTimeout(onTimeout, timeout);\n        }, timeout);\n\n        const unsub = () => {\n            [\"scroll\", \"resize\"].forEach((e) =>\n                window.removeEventListener(e, onInteraction)\n            );\n            [\n                \"click\",\n                \"keypress\",\n                \"keyup\",\n                \"mousemove\",\n                \"touchstart\",\n                \"touchend\",\n            ].forEach((e) => document.removeEventListener(e, onInteraction));\n        };\n\n        onInteraction();\n\n        [\"scroll\", \"resize\"].forEach((e) => window.addEventListener(e, onInteraction));\n        [\"click\", \"keypress\", \"keyup\", \"mousemove\", \"touchstart\", \"touchend\"].forEach(\n            (e) => document.addEventListener(e, onInteraction)\n        );\n    },\n\n    // XXX: simple so far to see what the team thinks of the idea\n    registerTypeHandler(type, handler) {\n        this.handlers[type] = handler;\n    },\n\n    async callTypeHandler(type, fn, context, params) {\n        type = type || \"html\";\n        if (this.handlers[type] && $.isFunction(this.handlers[type][fn])) {\n            return await this.handlers[type][fn].bind(this)(...params);\n        } else {\n            return null;\n        }\n    },\n\n    handlers: {\n        html: {\n            sources(cfgs, data) {\n                const sources = cfgs.map((cfg) => cfg.source);\n                sources.push(\"title\");\n                return this._sourcesFromHtml(data, cfgs[0].url, sources);\n            },\n        },\n    },\n};\n\n$(document).on(\"patterns-injected.inject\", (ev, cfg, trigger, injected) => {\n    /* Listen for the patterns-injected event.\n     *\n     * Remove the \"loading-class\" classes from all injection targets and\n     * then scan the injected content for new patterns.\n     */\n    if (cfg && cfg.skipPatInjectHandler) {\n        // Allow skipping this handler but still have other handlers in other\n        // patterns listen to ``patterns-injected``.\n        return;\n    }\n    if (cfg) {\n        cfg.$target.removeClass(cfg.loadingClass);\n        // Remove the executing class, add the executed class to the element with pat.inject on it.\n        $(trigger).removeClass(cfg.executingClass).addClass(cfg.executedClass);\n    }\n    if (injected.nodeType !== TEXT_NODE && injected !== COMMENT_NODE) {\n        registry.scan(injected, null, { type: \"injection\", element: trigger });\n        $(injected).trigger(\"patterns-injected-scanned\");\n    }\n});\n\n$(window).on(\"popstate\", (event) => {\n    // popstate also triggers on traditional anchors\n    if (!event.originalEvent.state && \"replaceState\" in history) {\n        try {\n            history.replaceState(\"anchor\", \"\", document.location.href);\n        } catch (e) {\n            log.debug(e);\n        }\n        return;\n    }\n    // Not only change the URL, also reload the page.\n    window.location.reload();\n});\n\n// this entry ensures that the initally loaded page can be reached with\n// the back button\nif (\"replaceState\" in history) {\n    try {\n        history.replaceState(\"pageload\", \"\", document.location.href);\n    } catch (e) {\n        log.debug(e);\n    }\n}\n\nregistry.register(inject);\nexport default inject;\n","import \"regenerator-runtime/runtime\"; // needed for ``await`` support\nimport $ from \"jquery\";\nimport logging from \"../../core/logging\";\nimport utils from \"../../core/utils\";\nimport Base from \"../../core/base\";\nimport inject from \"../inject/inject\";\n\nvar log = logging.getLogger(\"pat.markdown\");\nvar is_markdown_resource = /\\.md$/;\n\nvar Markdown = Base.extend({\n    name: \"markdown\",\n    trigger: \".pat-markdown\",\n\n    async init() {\n        if (this.$el.is(this.trigger)) {\n            /* This pattern can either be used standalone or as an enhancement\n             * to pat-inject. The following only applies to standalone, when\n             * $el is explicitly configured with the pat-markdown trigger.\n             */\n            var source = this.$el.is(\":input\") ? this.$el.val() : this.$el.text();\n            let rendered = await this.render(source);\n            rendered.replaceAll(this.$el);\n        }\n    },\n\n    async render(text) {\n        const Showdown = (await import(\"showdown\")).default;\n\n        // Add support for syntax highlighting via pat-syntax-highlight\n        Showdown.extensions.prettify = function () {\n            return [\n                {\n                    type: \"output\",\n                    filter: function (source) {\n                        return source.replace(/(<pre>)?<code>/gi, function (match, pre) {\n                            if (pre) {\n                                return '<pre class=\"pat-syntax-highlight\" tabIndex=\"0\"><code data-inner=\"1\">';\n                            } else {\n                                return '<code class=\"pat-syntax-highlight\">';\n                            }\n                        });\n                    },\n                },\n            ];\n        };\n\n        const $rendering = $(\"<div/>\");\n        const converter = new Showdown.Converter({\n            tables: true,\n            extensions: [\"prettify\"],\n        });\n        $rendering.html(converter.makeHtml(text));\n        return $rendering;\n    },\n\n    async renderForInjection(cfg, data) {\n        var header,\n            source = data;\n        if (cfg.source && (header = /^#+\\s*(.*)/.exec(cfg.source)) !== null) {\n            source = this.extractSection(source, header[1]);\n            if (source === null) {\n                log.warn('Could not find section \"' + cfg.source + '\" in ' + cfg.url);\n                return $(\"<div/>\").attr(\"data-src\", cfg.url);\n            }\n            source += \"\\n\"; // Needed for some markdown syntax\n        }\n        const rendered = await this.render(source);\n        return rendered.attr(\"data-src\", cfg.source ? cfg.url + cfg.source : cfg.url);\n    },\n\n    extractSection(text, header) {\n        var pattern, level;\n        header = utils.escapeRegExp(header);\n        var matcher = new RegExp(\n                \"^((#+)\\\\s*@TEXT@\\\\s*|@TEXT@\\\\s*\\\\n([=-])+\\\\s*)$\".replace(\n                    /@TEXT@/g,\n                    header\n                ),\n                \"m\"\n            ),\n            match = matcher.exec(text);\n        if (match === null) {\n            return null;\n        } else if (match[2]) {\n            // We have a ##-style header.\n            level = match[2].length;\n            pattern =\n                \"^#{@LEVEL@}\\\\s*@TEXT@\\\\s*$\\\\n+((?:.|\\\\n)*?(?=^#{1,@LEVEL@}\\\\s)|.*(?:.|\\\\n)*)\";\n            pattern = pattern.replace(/@LEVEL@/g, level);\n        } else if (match[3]) {\n            // We have an underscore-style header.\n            if (match[3] === \"=\")\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n=+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n=+\\\\s*$)|(?:.|\\\\n)*)\";\n            else\n                pattern =\n                    \"^@TEXT@\\\\s*\\\\n-+\\\\s*\\\\n+((?:.|\\\\n)*?(?=^.*?\\\\n[-=]+\\\\s*$)|(?:.|\\\\n)*)\";\n        } else {\n            log.error(\"Unexpected section match result\", match);\n            return null;\n        }\n        pattern = pattern.replace(/@TEXT@/g, header);\n        matcher = new RegExp(pattern, \"m\");\n        match = matcher.exec(text);\n        if (match === null) {\n            log.error(\"Failed to find section with known present header?\");\n        }\n        return match !== null ? match[0] : null;\n    },\n});\n\n$(document).ready(function () {\n    $(document.body).on(\n        \"patterns-inject-triggered.pat-markdown\",\n        \"a.pat-inject\",\n        function identifyMarkdownURLs() {\n            /* Identify injected URLs which point to markdown files and set their\n             * datatype so that we can register a type handler for them.\n             */\n            var cfgs = $(this).data(\"pat-inject\");\n            cfgs.forEach(function (cfg) {\n                if (is_markdown_resource.test(cfg.url)) {\n                    cfg.dataType = \"markdown\";\n                }\n            });\n        }\n    );\n});\n\ninject.registerTypeHandler(\"markdown\", {\n    async sources(cfgs, data) {\n        return await Promise.all(\n            cfgs.map(async function (cfg) {\n                var pat = Markdown.init(cfg.$target);\n                const rendered = await pat.renderForInjection(cfg, data);\n                return rendered;\n            })\n        );\n    },\n});\n\nexport default Markdown;\n"],"names":["methods","init","options","settings","time","initialTime","exceptionAreas","this","each","$this","data","lastEvent","Date","trueTime","untouched","inExceptionArea","on","mouseMoved","find","live","parent","enteredException","leftException","timeout","addClass","event","trigger","destroy","window","off","remove","removeData","hasClass","removeClass","startTimer","fn","setTimeout","Math","floor","now","diff","method","apply","Array","prototype","slice","call","arguments","scrollable","element","css","clientHeight","scrollHeight","clientWidth","scrollWidth","parent_id","absoluteParent","parents","length","elemTop","position","top","elemBottom","height","viewTop","scrollTop","viewBottom","docElem","elem","origin","left","nodeType","ownerDocument","document","documentElement","offsettop","offsetleft","thiswidth","width","pos","safeOffset","setleft","settop","appendTo","show","selector","$ancestor","closest","$child","childMarginEdgeLeft","parseInt","childMarginEdgeTop","ancestorPaddingEdgeLeft","ancestorPaddingEdgeTop","addBack","filter","speed","easing","callback","animate","a","i","m","text","toUpperCase","indexOf","log","logging","addArgument","$el","is","attr","split","cache","xhrCount","undefined","get","_","name","parser","onTriggerEvents","onClickSubmit","warn","$form","target","first","value","val","preventDefault","request","opts","_request","cfg","parse","seqNumber","inc","url","temp","clickedData","args","context","serialize","Boolean","join","headers","accept","Accept","formdata","FormData","key","append","debug","ajax_deferred","done","status","jqxhr","type","fail","error","registry","inject","cfgs","extractConfig","some","e","history","nextHref","href","location","pushMarker","onTrigger","currentTarget","idleTrigger","_initIdleTrigger","forEach","delay","processDelay","bind","ajax","onFormActionSubmit","uid","random","toString","delayed_trigger","uid_","_initAutoloadVisible","v","params","serializeArray","execute","$button","formaction","$cfg_node","submitSubform","$sub","$context","urlparts","defaultSelector","utils","elementIsDirty","askForConfirmation","message","should_confirm","_confirm","confirm","$target","confirmMessage","ensureTarget","createTarget","$injected","verifySingleConfig","source","extractModifiers","listenForFormReset","verifyConfig","every","html","source_match","exec","target_match","sourceMod","targetMod","targetPosition","loadingClass","action","id","stopBubblingFromRemovedElement","ev","sel","isPropagationStopped","stopPropagation","_performInjection","$source","title","$src","contents","all","querySelector","addEventListener","map","idx","el","outerHTML","safeClone","findInclusive","_inject","_afterInjection","glue","pushState","el_","scroll","scroll_container","scroll_target","scroll_container_ref","body","abs","getBoundingClientRect","scrollLeft","scrollTo","dispatchEvent","Event","bubbles","cancelable","async","responseText","hooks","hook","sources$","callTypeHandler","dataType","nodeName","idx1","perform_inject","idx2","replace","explanation","timestamp","error_page","error_page_fragment","URLSearchParams","search","error_page_url","getAttribute","createElement","innerHTML","error_page_response","fetch","executingClass","error_zone","msg_attr","statusText","removeAttr","_onInjectSuccess","_onInjectError","contentbefore","contentafter","elementbefore","elementafter","replaceWith","empty","_sourcesFromHtml","sources","$html","_parseRawHtml","_rebaseAttrs","A","FORM","IMG","OBJECT","SOURCE","VIDEO","_rebaseOptions","_rebaseHTML","base","$page","trim","wrapAll","Object","keys","$el_","attrName","tagName","pattern_name","entries","dom","pattern","pattern_parser","changed","config","opt","isArray","it","setAttribute","JSON","stringify","match","clean_html","children","$scrollable","click","checkVisibility","IntersectionObserver","observer","observe","timer","onTimeout","unsub","clearTimeout","onInteraction","contains","removeEventListener","registerTypeHandler","handler","handlers","push","injected","skipPatInjectHandler","executedClass","originalEvent","state","reload","replaceState","is_markdown_resource","Markdown","render","replaceAll","Showdown","default","extensions","prettify","pre","$rendering","converter","Converter","tables","makeHtml","header","extractSection","level","matcher","RegExp","ready","test","Promise","pat","renderForInjection"],"sourceRoot":""}